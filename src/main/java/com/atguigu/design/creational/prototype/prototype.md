### 核心：

本体给使用者一个克隆体

### 场景

1. 资源优化
2. 性能、安全要求
3. 一个对象多个修改者的场景
4. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以考虑使用原型模式拷贝多个对象供调用者使用

## 深(递归克隆)、浅(属性赋值)...

在Java中，克隆分为深克隆（Deep Copy）和浅克隆（Shallow Copy），这两种克隆方式主要区别在于对象复制的深度。

### 浅克隆（Shallow Copy）

- 浅克隆仅复制对象的基本数据类型的字段值和对象的引用，而不复制引用指向的对象。
- 使用浅克隆，克隆出来的对象和原始对象会共享引用类型的字段。也就是说，如果原始对象或克隆对象中的一个引用类型字段发生变化，这种变化会反映在另一个对象上。
- 在Java中，可以通过实现`Cloneable`接口并重写`Object`类的`clone()`方法来实现浅克隆。

### 深克隆（Deep Copy）

- 深克隆不仅复制对象的基本数据类型的字段值，而且复制对象中的所有引用类型字段所指向的对象，这意味着克隆出的对象与原对象在内存中是完全独立的。
- 使用深克隆，克隆出的对象与原对象不会共享任何引用类型的字段。修改克隆对象的引用类型字段不会对原对象产生影响，反之亦然。
- 实现深克隆较为复杂，需要对对象中的所有引用类型字段进行递归地克隆。这通常可以通过重写`clone()`
  方法并在其中手动克隆所有引用类型，或者使用序列化（实现`Serializable`接口，通过对象的序列化和反序列化来实现深克隆）来完成。

### 比较

| 特性    | 浅克隆                           | 深克隆                    |
|-------|-------------------------------|------------------------|
| 实现难度  | 较简单                           | 较复杂                    |
| 性能    | 通常较快                          | 由于需要递归复制所有对象，因此较慢      |
| 数据独立性 | 引用类型字段共享                      | 完全独立                   |
| 使用场景  | 当对象中没有复杂的引用类型或共享引用类型字段是可接受的情况 | 需要完全独立复制对象，包括其引用的所有对象时 |

### 总结

选择浅克隆还是深克隆取决于具体的需求。如果需要完全独立的对象副本，应使用深克隆；如果共享部分数据是可接受的，或者为了性能考虑，可以使用浅克隆。深克隆的实现更复杂，但它提供了更高的数据隔离级别。